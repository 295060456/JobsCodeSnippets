<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDECodeSnippetCompletionPrefix</key>
	<string></string>
	<key>IDECodeSnippetCompletionScopes</key>
	<array>
		<string>All</string>
	</array>
	<key>IDECodeSnippetContents</key>
	<string>//
//  UIAlertController+BG.swift
//  JobsSwiftBaseConfigDemo
//
//  Created by Jobs on 2025/6/16.
//

#if os(OSX)
import AppKit
#endif

#if os(iOS) || os(tvOS)
import UIKit
#endif

#if canImport(RxSwift) &amp;&amp; canImport(RxCocoa)
import RxSwift
import RxCocoa
#endif

import NSObject_Rx
import SnapKit

// ================================== æ„å»º &amp; é…ç½® ==================================
public extension UIAlertController {
    // MARK: å·¥å‚
    @discardableResult
    static func makeAlert(_ title: String? = nil,
                          _ message: String? = nil) -&gt; UIAlertController {
        UIAlertController(title: title, message: message, preferredStyle: .alert)
    }

    @discardableResult
    static func makeActionSheet(_ title: String? = nil,
                                _ message: String? = nil) -&gt; UIAlertController {
        UIAlertController(title: title, message: message, preferredStyle: .actionSheet)
    }

    // MARK: åŸºç¡€å±æ€§
    @discardableResult
    func byMessage(_ message: String?) -&gt; Self {
        self.message = message
        return self
    }

    @available(iOS 16.0, *)
    @discardableResult
    func bySeverity(_ severity: UIAlertControllerSeverity) -&gt; Self {
        self.severity = severity
        return self
    }

    @discardableResult
    func byTintColor(_ color: UIColor?) -&gt; Self {
        if let color { self.view.tintColor = color }
        return self
    }

    // MARK: Actions
    @discardableResult
    func byAddAction(title: String,
                     style: UIAlertAction.Style = .default,
                     isPreferred: Bool = false,
                     handler: ((UIAlertAction) -&gt; Void)? = nil) -&gt; Self {
        let action = UIAlertAction(title: title, style: style, handler: handler)
        self.addAction(action)
        if isPreferred { self.preferredAction = action }
        return self
    }

    @discardableResult
    func byAddAction(title: String,
                     style: UIAlertAction.Style = .default,
                     isPreferred: Bool = false,
                     byActionBlock handler: @escaping (_ alert: UIAlertController, _ action: UIAlertAction) -&gt; Void) -&gt; Self {
        let action = UIAlertAction(title: title, style: style) { [weak self] act in
            guard let alert = self else { return }
            handler(alert, act)
        }
        self.addAction(action)
        if isPreferred { self.preferredAction = action }
        return self
    }

    @discardableResult
    func byAddOK(_ title: String = "ç¡®å®š",
                 isPreferred: Bool = true,
                 _ handler: ((UIAlertAction) -&gt; Void)? = nil) -&gt; Self {
        byAddAction(title: title, style: .default, isPreferred: isPreferred, handler: handler)
    }

    @discardableResult
    func byAddOK(_ title: String = "ç¡®å®š",
                 isPreferred: Bool = true,
                 _ handler: @escaping (_ alert: UIAlertController, _ action: UIAlertAction) -&gt; Void) -&gt; Self {
        byAddAction(title: title, style: .default, isPreferred: isPreferred, byActionBlock: handler)
    }

    @discardableResult
    func byAddCancel(_ title: String = "å–æ¶ˆ",
                     _ handler: ((UIAlertAction) -&gt; Void)? = nil) -&gt; Self {
        byAddAction(title: title, style: .cancel, handler: handler)
    }

    @discardableResult
    func byAddCancel(_ title: String = "å–æ¶ˆ",
                     _ handler: @escaping (_ alert: UIAlertController, _ action: UIAlertAction) -&gt; Void) -&gt; Self {
        byAddAction(title: title, style: .cancel, byActionBlock: handler)
    }

    @discardableResult
    func byAddDestructive(_ title: String,
                          handler: ((UIAlertAction) -&gt; Void)? = nil) -&gt; Self {
        byAddAction(title: title, style: .destructive, handler: handler)
    }

    @discardableResult
    func byAddDestructive(_ title: String,
                          withAlert handler: @escaping (_ alert: UIAlertController, _ action: UIAlertAction) -&gt; Void) -&gt; Self {
        byAddAction(title: title, style: .destructive, byActionBlock: handler)
    }

    @discardableResult
    func byPreferredAction(_ action: UIAlertAction?) -&gt; Self {
        self.preferredAction = action
        return self
    }

    @discardableResult
    func byPreferredActionTitle(_ title: String) -&gt; Self {
        if let hit = actions.first(where: { $0.title == title }) { self.preferredAction = hit }
        return self
    }

    // MARK: TextFieldsï¼ˆåŸºç¡€ï¼‰
    func textField(at index: Int) -&gt; UITextField? {
        guard let tfs = self.textFields, (0..&lt;tfs.count).contains(index) else { return nil }
        return tfs[index]
    }
}

// ================================== TextFieldï¼šRAC ç›‘å¬ï¼ˆå¯é€‰ï¼‰ ==================================
#if canImport(RxSwift) &amp;&amp; canImport(RxCocoa)
import RxSwift
import RxCocoa

final class JobsTextFieldDelegateProxy:
    DelegateProxy&lt;UITextField, UITextFieldDelegate&gt;,
    DelegateProxyType,
    UITextFieldDelegate {

    init(textField: UITextField) {
        super.init(parentObject: textField, delegateProxy: JobsTextFieldDelegateProxy.self)
    }

    static func registerKnownImplementations() {
        self.register { JobsTextFieldDelegateProxy(textField: $0) }
    }

    static func currentDelegate(for object: UITextField) -&gt; UITextFieldDelegate? { object.delegate }
    static func setCurrentDelegate(_ delegate: UITextFieldDelegate?, to object: UITextField) { object.delegate = delegate }
}

public extension UIAlertController {
    @discardableResult
    func byAddTextField(placeholder: String?,
                        text: String? = nil,
                        isSecure: Bool = false,
                        keyboard: UIKeyboardType = .default,
                        returnKey: UIReturnKeyType = .done,
                        textContentType: UITextContentType = .password,
                        leftView: UIView? = nil,
                        rightView: UIView? = nil,
                        autocorrection: UITextAutocorrectionType = .default,
                        capitalization: UITextAutocapitalizationType = .none,
                        contentType: UITextContentType? = nil,
                        // æ ·å¼ï¼ˆå¯é€‰ï¼‰
                        borderWidth: CGFloat? = nil,
                        borderColor: UIColor? = nil,
                        cornerRadius: CGFloat? = nil,
                        onChange: @escaping (_ alert: UIAlertController,
                                             _ tf: UITextField,
                                             _ input: String,
                                             _ oldText: String,
                                             _ isDeleting: Bool) -&gt; Void) -&gt; Self {
        self.addTextField { [weak self] tf in
            tf.byPlaceholder(placeholder)
                .byText(text)
                .byReturnKeyType(returnKey)
                .byTextContentType(textContentType)
                .byLeftView(leftView)
                .byRightView(rightView)
                .bySecureTextEntry(isSecure)
                .byKeyboardType(keyboard)
                .byAutocorrectionType(autocorrection)
                .byAutocapitalizationType(capitalization)
                .byTextContentType(contentType)

            var didStyle = false
            if let w = borderWidth { tf.layer.borderWidth = w; didStyle = true }
            if let c = borderColor { tf.layer.borderColor = c.cgColor; didStyle = true }
            if let r = cornerRadius { tf.layer.cornerRadius = r; didStyle = true }
            if didStyle {
                tf.layer.masksToBounds = true
                if #available(iOS 13.0, *) { tf.layer.cornerCurve = .continuous }
            }

            guard let alert = self else { return }
            var previousText = tf.text ?? ""

            tf.rx.controlEvent(.editingChanged)
                .subscribe(onNext: { [weak alert, weak tf] in
                    guard let alert = alert, let tf = tf else { return }
                    let currentText = tf.text ?? ""
                    let isDeleting = currentText.count &lt; previousText.count
                    var input = ""
                    if !isDeleting {
                        if currentText.hasPrefix(previousText) {
                            input = String(currentText.dropFirst(previousText.count))
                        } else {
                            input = currentText
                        }
                    }
                    onChange(alert, tf, input, previousText, isDeleting)
                    previousText = currentText
                })
                .disposed(by: tf.disposeBag)
        }
        return self
    }
}
#endif

// ================================== ç»Ÿä¸€é”šç‚¹ &amp; ä¸€è¡Œå±•ç¤º ==================================
public extension UIAlertController {
    enum Anchor {
        case auto
        case barButton(UIBarButtonItem)
        case view(UIView, CGRect? = nil, UIPopoverArrowDirection = [])
    }

    @discardableResult
    func byAnchor(_ anchor: Anchor, host: UIViewController) -&gt; Self {
        guard let pop = self.popoverPresentationController else { return self }
        switch anchor {
        case .barButton(let item):
            pop.barButtonItem = item
        case .view(let v, let rect, let arrows):
            pop.sourceView = v
            pop.sourceRect = rect ?? v.bounds
            pop.permittedArrowDirections = arrows
        case .auto:
            pop.sourceView = host.view
            pop.sourceRect = CGRect(x: host.view.bounds.midX,
                                    y: host.view.bounds.maxY - 1,
                                    width: 1, height: 1)
            pop.permittedArrowDirections = []
        }
        return self
    }

    /// presentï¼šä¸ç³»ç»Ÿè½¬åœºåè°ƒæ‰§è¡Œï¼ˆæœ¬åœ°èƒŒæ™¯å°†è¢«â€œå¼ºåˆ¶åŒæ­¥å®‰è£…â€ï¼‰
    @discardableResult
    func byPresent(_ vc: UIViewController,
                   anchor: Anchor = .auto,
                   animated: Bool = true,
                   completion: (() -&gt; Void)? = nil) -&gt; Self {

        let isSheet: Bool = {
            switch vc.modalPresentationStyle {
            case .pageSheet, .formSheet, .automatic: return true
            default: return false
            }
        }()

        let host = (isSheet ? vc.presentingViewController : nil) ?? vc

        if self.popoverPresentationController != nil {
            self.byAnchor(anchor, host: host)
        }

        // ğŸš€ å…³é”®ï¼šåœ¨ present ä¹‹å‰å¼ºåˆ¶åŠ è½½ view å¹¶åŒæ­¥å®‰è£…æœ¬åœ°å›¾ï¼ˆé¿å…ä½ è¯´çš„â€œæœ¬åœ°ä¸æ˜¾ç¤ºâ€ï¼‰
        self.loadViewIfNeeded()
        self.view.setNeedsLayout()
        self.view.layoutIfNeeded()
        _installLocalBGIfPending() // å°½åŠ›å…ˆè£…ä¸€æ¬¡

        host.present(self, animated: animated) { [weak self] in
            guard let self else { completion?(); return }

            if let tc = self.transitionCoordinator {
                tc.animate(alongsideTransition: { _ in
                    // å†æ¬¡ç¡®ä¿æœ¬åœ°èƒŒæ™¯å·²å°±ä½ï¼ˆä¸ç³»ç»ŸåŠ¨ç”»åŒå¸§ï¼Œæ— é—ªçƒï¼‰
                    UIView.performWithoutAnimation {
                        self._installLocalBGIfPending()
                        self._drainPreBGTasks()
                    }
                }, completion: { _ in
                    self._drainPostBGTasks()
                    // å†å…œåº•ä¸€æ¬¡ï¼šä¸‹ä¸€è½® RunLoop
                    DispatchQueue.main.async { [weak self] in
                        self?._installLocalBGIfPending()
                        self?._drainPostBGTasks()
                    }
                })
            } else {
                // æ²¡æœ‰åè°ƒå™¨ï¼ˆæå°‘æ•°æƒ…å†µï¼‰ï¼šæŒ‰é¡ºåºå…œåº•
                UIView.performWithoutAnimation {
                    self._installLocalBGIfPending()
                    self._drainPreBGTasks()
                }
                self._drainPostBGTasks()
                DispatchQueue.main.async { [weak self] in
                    self?._installLocalBGIfPending()
                    self?._drainPostBGTasks()
                }
            }
            completion?()
        }
        return self
    }
}

// MARK: - AOï¼ˆUInt8 å“¨å…µï¼‰
private struct _JobsAO {
    // èƒŒæ™¯å®‰è£…ä»»åŠ¡é˜Ÿåˆ—ï¼ˆè½¬åœºå‰/åå„ä¸€é˜Ÿï¼‰â€”â€”ä»…ç”¨äºâ€œéèƒŒæ™¯å›¾â€çš„ä»»åŠ¡
    static var bgTasksPreKey:  UInt8 = 0
    static var bgTasksPostKey: UInt8 = 0

    // æœ¬åœ°èƒŒæ™¯ï¼ˆåŒæ­¥ä¼˜å…ˆå®‰è£…ï¼‰
    static var localBGImageKey: UInt8 = 0
    static var localBGHideBackdropKey: UInt8 = 0
}
private extension UIAlertController {
    typealias _BGTask = (UIAlertController) -&gt; Void

    var _bgTasksPre:  [_BGTask] {
        get { (objc_getAssociatedObject(self, &amp;_JobsAO.bgTasksPreKey)  as? [_BGTask]) ?? [] }
        set { objc_setAssociatedObject(self, &amp;_JobsAO.bgTasksPreKey,  newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }
    var _bgTasksPost: [_BGTask] {
        get { (objc_getAssociatedObject(self, &amp;_JobsAO.bgTasksPostKey) as? [_BGTask]) ?? [] }
        set { objc_setAssociatedObject(self, &amp;_JobsAO.bgTasksPostKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }

    func _enqueueBGTask(preTransition: Bool, _ task: @escaping _BGTask) {
        if preTransition { _bgTasksPre.append(task) } else { _bgTasksPost.append(task) }
    }
    func _drainPreBGTasks()  { let t = _bgTasksPre;  _bgTasksPre.removeAll();  t.forEach { $0(self) } }
    func _drainPostBGTasks() { let t = _bgTasksPost; _bgTasksPost.removeAll(); t.forEach { $0(self) } }

    // -------- æœ¬åœ°èƒŒæ™¯ AO --------
    var _localBGImage: UIImage? {
        get { objc_getAssociatedObject(self, &amp;_JobsAO.localBGImageKey) as? UIImage }
        set { objc_setAssociatedObject(self, &amp;_JobsAO.localBGImageKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }
    var _localBGHideBackdrop: Bool {
        get { (objc_getAssociatedObject(self, &amp;_JobsAO.localBGHideBackdropKey) as? Bool) ?? true }
        set { objc_setAssociatedObject(self, &amp;_JobsAO.localBGHideBackdropKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
    }
}

// MARK: - èƒŒæ™¯å›¾ï¼ˆæœ¬åœ° / SD / KFï¼‰â€” æœ¬åœ°â€œå¼ºåˆ¶åŒæ­¥â€ï¼Œç½‘ç»œâ€œè½¬åœºåæ·¡å…¥â€
public extension UIAlertController {
    /// æœ¬åœ°å›¾ç‰‡ï¼š**å¼ºåˆ¶åŒæ­¥å®‰è£…**ï¼ˆpresent å‰å°è¯•ä¸€æ¬¡ï¼›è½¬åœºå¼€å§‹æ—¶å†ç¡®ä¿ä¸€æ¬¡ï¼‰
    @discardableResult
    func byBgImage(
        _ image: UIImage?,
        hideSystemBackdrop: Bool = true
    ) -&gt; Self {
        _localBGImage = image ?? jobsSolidBlue()
        _localBGHideBackdrop = hideSystemBackdrop

        // ç«‹å³å°è¯•å®‰è£…ä¸€æ¬¡ï¼ˆå¦‚ view å·²åŠ è½½å³å¯ç”Ÿæ•ˆï¼‰
        self.loadViewIfNeeded()
        self.view.setNeedsLayout()
        self.view.layoutIfNeeded()
        _installLocalBGIfPending()
        return self
    }

    /// SDï¼šURL ä¸ºç©ºåˆ™åªè£…æœ¬åœ°å›¾ï¼›æœ‰ URL æ—¶è½¬åœºåæ·¡å…¥ç½‘ç»œå›¾
    @discardableResult
    func bySDBgImageView(
        _ url: String,
        image: UIImage? = nil,
        hideSystemBackdrop: Bool = true,
        crossfade: TimeInterval = 0.2
    ) -&gt; Self {
        // 1) å…ˆåŒæ­¥å®‰è£…æœ¬åœ°å ä½ï¼ˆä¿è¯â€œç«‹åˆ»èƒ½çœ‹è§â€ï¼‰
        _ = byBgImage(image ?? jobsSolidBlue(), hideSystemBackdrop: hideSystemBackdrop)

        // 2) å†åœ¨è½¬åœºå®Œæˆåæ·¡å…¥ç½‘ç»œå›¾
        let trimmed = url.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return self }

        _enqueueBGTask(preTransition: false) { alert in
            Task { @MainActor in
                alert._withAlertCard { card in
                    let iv = alert._ensureBGImageView(in: card)
                    let placeholder = iv.image ?? (image ?? jobsSolidBlue())
                    let img = await trimmed.sdLoadImage(fallbackImage: placeholder)
                    if crossfade &gt; 0 {
                        alert._crossfade(iv, to: img, duration: crossfade)
                    } else {
                        iv.image = img
                    }
                    iv.layer.cornerRadius = card.layer.cornerRadius
                }
            }
        }
        return self
    }

    /// KFï¼šURL ä¸ºç©ºåˆ™åªè£…æœ¬åœ°å›¾ï¼›æœ‰ URL æ—¶è½¬åœºåæ·¡å…¥ç½‘ç»œå›¾
    @discardableResult
    func byKFBgImageView(
        _ url: String,
        image: UIImage? = nil,
        hideSystemBackdrop: Bool = true,
        crossfade: TimeInterval = 0.2
    ) -&gt; Self {
        // 1) å…ˆåŒæ­¥å®‰è£…æœ¬åœ°å ä½
        _ = byBgImage(image ?? jobsSolidBlue(), hideSystemBackdrop: hideSystemBackdrop)

        // 2) å†è½¬åœºåæ·¡å…¥ç½‘ç»œå›¾
        let trimmed = url.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return self }

        _enqueueBGTask(preTransition: false) { alert in
            Task { @MainActor in
                alert._withAlertCard { card in
                    let iv = alert._ensureBGImageView(in: card)
                    let placeholder = iv.image ?? (image ?? jobsSolidBlue())
                    let img = await trimmed.kfLoadImage(fallbackImage: placeholder)
                    if crossfade &gt; 0 {
                        alert._crossfade(iv, to: img, duration: crossfade)
                    } else {
                        iv.image = img
                    }
                    iv.layer.cornerRadius = card.layer.cornerRadius
                }
            }
        }
        return self
    }

    /// ç»™ Alert å¡ç‰‡åŠ æè¾¹ï¼ˆå¤–å±‚å®¹å™¨ï¼Œä¸æ˜¯è¾“å…¥æ¡†ï¼‰
    @discardableResult
    func byCardBorder(width: CGFloat,
                      color: UIColor,
                      cornerRadius: CGFloat? = nil) -&gt; Self {
        _enqueueBGTask(preTransition: true) { alert in
            Task { @MainActor in
                alert._withAlertCard { card in
                    card.layer.borderWidth = width
                    card.layer.borderColor = color.cgColor
                    if let r = cornerRadius { card.layer.cornerRadius = r }
                    card.layer.masksToBounds = true
                    if #available(iOS 13.0, *) { card.layer.cornerCurve = .continuous }
                }
            }
        }
        return self
    }

    /// ç»™æŒ‡å®š index çš„è¾“å…¥æ¡†ã€Œå¤–å±‚ç°è‰²å®¹å™¨ã€æè¾¹ï¼ˆä¸æ˜¯ UITextField è‡ªèº«ï¼‰
    @discardableResult
    func byTextFieldOuterBorder(at index: Int = 0,
                                width: CGFloat,
                                color: UIColor,
                                cornerRadius: CGFloat? = nil,
                                insets: UIEdgeInsets = .zero) -&gt; Self {
        _enqueueBGTask(preTransition: true) { alert in
            Task { @MainActor in
                alert._withAlertCard { _ in
                    guard let tf = alert.textField(at: index) else { return }
                    guard let box = alert._findTextFieldBox(for: tf) else { return }

                    let tag = 0x7F_54_19
                    let borderView: UIView
                    if let exist = box.viewWithTag(tag) {
                        borderView = exist
                    } else {
                        let v = UIView()
                        v.isUserInteractionEnabled = false
                        v.backgroundColor = .clear
                        v.tag = tag
                        box.insertSubview(v, belowSubview: tf) // æ”¾åœ¨ tf ä¸‹å±‚ï¼Œä¸æŒ¡äº¤äº’
                        v.snp.makeConstraints { make in
                            make.edges.equalToSuperview().inset(insets)
                        }
                        borderView = v
                    }

                    borderView.layer.borderWidth = width
                    borderView.layer.borderColor = color.cgColor
                    borderView.layer.cornerRadius = cornerRadius ?? box.layer.cornerRadius
                    borderView.layer.masksToBounds = true
                    if #available(iOS 13.0, *) { borderView.layer.cornerCurve = .continuous }
                }
            }
        }
        return self
    }
}
// MARK: - ç§æœ‰ï¼šæ‰¾å¡ç‰‡ / å®‰è£…èƒŒæ™¯ / è§†è§‰
public extension UIAlertController {
    /// æ‰¾åˆ°æ•´å¼  Alert çš„â€œå¡ç‰‡è§†å›¾â€
    @MainActor
    fileprivate func _findAlertCardView() -&gt; UIView? {
        // 0) ä¼˜å…ˆï¼šé€‰â€œå¯è§çš„ã€éæ ¹è§†å›¾çš„ã€å¸¦åœ†è§’çš„ã€é¢ç§¯æœ€å¤§çš„â€é‚£ä¸ª
        let all = view._allSubviews()
        let rounded = all.filter {
            $0 !== view &amp;&amp;
            !$0.isHidden &amp;&amp;
            $0.alpha &gt; 0.01 &amp;&amp;
            $0.layer.cornerRadius &gt; 1 &amp;&amp;
            $0.bounds.width &gt; 20 &amp;&amp; $0.bounds.height &gt; 20
        }
        if let big = rounded.max(by: { ($0.bounds.width * $0.bounds.height) &lt; ($1.bounds.width * $1.bounds.height) }) {
            return big
        }

        // 1) æ¬¡é€‰ï¼šé€šè¿‡ title/message çš„ UILabel å¾€ä¸Šæ‰¾
        let labels = all.compactMap { $0 as? UILabel }
        if let anchor = labels.first(where: { $0.text == title || $0.text == message }),
           let roundedFromLabel = anchor._firstAncestor(where: { $0.layer.cornerRadius &gt; 0 }) {
            return roundedFromLabel
        }

        // 2) UIVisualEffectView superview ä½œä¸ºå…œåº•
        if let effect = all.compactMap({ $0 as? UIVisualEffectView }).last,
           let sup = effect.superview, sup.layer.cornerRadius &gt; 0 {
            return sup
        }

        // 3) æœ€åå…œåº•ï¼šä»ç„¶æŒ‘é¢ç§¯æœ€å¤§çš„åœ†è§’è§†å›¾ï¼›éƒ½æ²¡æœ‰å°±ç”¨æ ¹ view
        let anyRounded = all.filter { $0.layer.cornerRadius &gt; 0 }
        return anyRounded.max(by: { ($0.bounds.width * $0.bounds.height) &lt; ($1.bounds.width * $1.bounds.height) }) ?? view
    }

    /// å®‰è£…/å¤ç”¨åº•å±‚èƒŒæ™¯å›¾ï¼ˆSnapKit çº¦æŸï¼Œä¸å‚ä¸æ’‘å¤§ï¼‰
    @MainActor
    fileprivate func _ensureBGImageView(in container: UIView) -&gt; UIImageView {
        if let exist = container.subviews.first(where: {
            ($0 as? UIImageView)?.accessibilityIdentifier == "jobs.alert.bg"
        }) as? UIImageView {
            return exist
        }

        let iv = UIImageView()
            .byUserInteractionEnabled(false)
            .byClipsToBounds(true)
            .byContentMode(.scaleAspectFill)
        iv.accessibilityIdentifier = "jobs.alert.bg"

        // é™ä½â€œå­˜åœ¨æ„Ÿâ€
        iv.setContentHuggingPriority(.init(1), for: .horizontal)
        iv.setContentHuggingPriority(.init(1), for: .vertical)
        iv.setContentCompressionResistancePriority(.init(1), for: .horizontal)
        iv.setContentCompressionResistancePriority(.init(1), for: .vertical)

        container.insertSubview(iv, at: 0)
        iv.snp.makeConstraints { make in
            make.edges.equalToSuperview()   // âœ… åªè´´è¾¹ï¼Œä¸åŠ  &lt;= çº¦æŸï¼Œé¿å…å¥‡æ€ªæ”¶ç¼©
        }

        return iv
    }
}
// MARK: - ç§æœ‰ï¼šåŒæ­¥å®‰è£…â€œæœ¬åœ°èƒŒæ™¯â€
private extension UIAlertController {
    @discardableResult
    @MainActor
    func _installLocalBGIfPending() -&gt; Bool {
        guard let img = _localBGImage else { return false }
        var did = false
        _withAlertCard { [weak self] card in
            guard let self else { return }
            if self._localBGHideBackdrop { self._hideBackdropAll(in: card) }
            let iv = self._ensureBGImageView(in: card)
            // âœ… å…³é”®ï¼šæ•´å¡ç‰‡è£å‰ªï¼ŒèƒŒæ™¯å›¾æŒ‰åœ†è§’è´´åˆæ•´å¼ å¡ç‰‡
            card.layer.masksToBounds = true
            iv.layer.cornerRadius = card.layer.cornerRadius
            iv.layer.masksToBounds = true
            UIView.performWithoutAnimation {
                iv.image = img
                iv.layoutIfNeeded()
            }
            did = true
        }
        return did
    }
}

public extension UIAlertController {
    /// åœ¨â€œæ•´å¼  Alert å¡ç‰‡â€å°±ç»ªåæ‰§è¡Œï¼ˆæ‰¾ä¸åˆ°å¡ç‰‡åˆ™ä¸‹ä¸€è½® RunLoop å†è¯•ä¸€æ¬¡ï¼Œæœ€åç”¨æ ¹ view å…œåº•ï¼‰
    @MainActor
    fileprivate func _withAlertCard(_ body: @escaping (_ card: UIView) async -&gt; Void) {
        if let card = _findAlertCardView() {
            Task { @MainActor in await body(card) }
            return
        }
        DispatchQueue.main.async { [weak self] in
            guard let self else { return }
            let card: UIView = self._findAlertCardView() ?? self.view
            Task { @MainActor in await body(card) }
        }
    }

    /// éšæ‰æ‰€æœ‰æ¯›ç»ç’ƒï¼Œå¹¶æ¸…æ‰å®¹å™¨åº•è‰²ï¼ˆä¾›æœ¬åœ°/ç½‘ç»œèƒŒæ™¯ç”Ÿæ•ˆæ—¶ä½¿ç”¨ï¼‰
    @MainActor
    fileprivate func _hideBackdropAll(in card: UIView) {
        func hideEffect(in v: UIView) {
            if v is UIVisualEffectView { v.isHidden = true }
            v.subviews.forEach(hideEffect)
        }
        hideEffect(in: card)
        card.backgroundColor = .clear
        view.backgroundColor = .clear
    }
    @MainActor
    fileprivate func _crossfade(_ iv: UIImageView,
                                to image: UIImage,
                                duration: TimeInterval) {
        guard duration &gt; 0 else {
            iv.image = image
            return
        }
        UIView.transition(with: iv,
                          duration: duration,
                          options: .transitionCrossDissolve,
                          animations: { iv.image = image },
                          completion: nil)
    }
    // æ‰¾åˆ° UITextField å¤–å±‚çš„â€œç°åº•å®¹å™¨â€ï¼ˆç”¨äºæè¾¹ç­‰ï¼‰
    // è¯´æ˜ï¼šä¸åŒ iOS ç‰ˆæœ¬å±‚çº§ä¸åŒï¼Œè¿™é‡Œç”¨ä¸€å¥—ä¿å®ˆå¯å‘å¼ï¼š
    //  - å…ˆçœ‹çˆ¶/ç¥–è§†å›¾æ˜¯å¦åƒå®¹å™¨ï¼ˆæœ‰åœ†è§’ / æœ‰å¯è§èƒŒæ™¯ / æ˜¯æ¯›ç»ç’ƒï¼‰
    //  - å†å‘ä¸Šé€çº§æ‰¾ç¬¬ä¸€ä¸ªâ€œåƒå®¹å™¨â€çš„ç¥–å…ˆ
    @MainActor
    fileprivate func _findTextFieldBox(for tf: UITextField) -&gt; UIView? {
        func looksLikeBox(_ v: UIView) -&gt; Bool {
            if v === tf { return false }
            if v.layer.cornerRadius &gt; 0 { return true }
            if (v.backgroundColor?.cgColor.alpha ?? 0) &gt; 0.01 { return true }
            if v is UIVisualEffectView { return true }
            return false
        }

        // 1) ç›´æ¥çˆ¶è§†å›¾å‘½ä¸­
        if let s1 = tf.superview, looksLikeBox(s1) { return s1 }
        // 2) ç¥–çˆ¶è§†å›¾å‘½ä¸­
        if let s2 = tf.superview?.superview, looksLikeBox(s2) { return s2 }

        // 3) å‘ä¸Šé€çº§æŸ¥æ‰¾
        var p = tf.superview
        while let v = p {
            if looksLikeBox(v) { return v }
            p = v.superview
        }

        // 4) å…œåº•ï¼šåœ¨åŒçº§å®¹å™¨é‡Œæ‰¾ä¸€ä¸ªâ€œåƒå®¹å™¨â€çš„å…„å¼Ÿè§†å›¾
        if let container = tf.superview?.superview {
            for v in container.subviews where v !== tf {
                if looksLikeBox(v) { return v }
            }
        }
        return nil
    }

}
</string>
	<key>IDECodeSnippetIdentifier</key>
	<string>113DBBDE-5F8D-489F-846E-F59296765C4A</string>
	<key>IDECodeSnippetLanguage</key>
	<string>Xcode.SourceCodeLanguage.Swift</string>
	<key>IDECodeSnippetSummary</key>
	<string></string>
	<key>IDECodeSnippetTitle</key>
	<string>My Code Snippet</string>
	<key>IDECodeSnippetUserSnippet</key>
	<true/>
	<key>IDECodeSnippetVersion</key>
	<integer>0</integer>
</dict>
</plist>
